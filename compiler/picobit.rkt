#lang racket

(require "utilities.rkt"
         "ast.rkt"
         "env.rkt"
         "reader.rkt"
         "parser.rkt"
         "front-end.rkt"
         "ir.rkt"
         "comp.rkt"
         "back-end.rkt"
         "assembler.rkt"
         "analysis.rkt"
         "scheduling.rkt"
         "tree-shaker.rkt")
(require racket/pretty)

;;-----------------------------------------------------------------------------

(define (compile in-port out-port-thunk)
  (let* ([forms        (read-program in-port)]
         [node         (parse-program forms global-env)])
    (when (show-parsed?)
      (pretty-print (node->expr node)))
    (adjust-unmutable-references! node)
    ;; done first to expose more left-left-lambdas, help constant folding, etc.
    (copy-propagate!              node)
    (inline-left-left-lambda!     node) ; gives constant folding more to do
    (inline-calls-to-calls!       node) ; same
    (copy-propagate!              node) ; same
    (constant-fold!               node)
    (copy-propagate!              node) ; again, for cleanup
    ;; analysis needed by the back-end
    (mark-needed-global-vars!     node)
    (when (show-post-front-end?)
      (pretty-print (node->expr node)))
    (let* ([ctx  (comp-none node (make-init-context))]
           [code (context-code ctx)]
           [bbs  (code->vector code)])
      (resolve-toplevel-labels! bbs)
      (let ([prog (schedule (tree-shake! bbs))])
        (when (show-asm?)
          (pretty-print prog))
        ;; output port is in a thunk to avoid creating result
        ;; files if compilation fails
        (let ([size (assemble prog (out-port-thunk))])
          (when (show-size?)
            (printf "~a bytes\n" size)))))))

(define output-file-gen
  (make-parameter
   (lambda (in)
     (let ([hex-filename (path-replace-suffix in ".hex")])
       ;; r5rs's with-output-to-file (in asm.rkt) can't overwrite. bleh
       (when (file-exists? hex-filename)
         (delete-file hex-filename))
       hex-filename))))

(command-line
 #:once-each
 [("--size")
  "Display the size of the generated bytecode."
  (show-size?  #t)]
 [("--parse")
  "Display post-parsing representation of the program."
  (show-parsed? #t)]
 [("--front")
  "Display post-front-end representation of the program."
  (show-post-front-end? #t)]
 [("-S" "--asm")
  "Display generated bytecode pre-assembly."
  (show-asm? #t)]
 [("--stats")
  "Display statistics about generated instructions."
  (stats? #t)]
 [("-o") out
  "Place the output into the given file."
  (output-file-gen (lambda (in) out))]
 #:args (filename)
 (void
  (if (equal? filename "-")
      ;; read input from stdin, produce code on stdout
      (compile
       (current-input-port)
       (lambda () (current-output-port)))
      (compile
       (open-input-file filename)
       (lambda () (open-output-file ((output-file-gen) filename)))))))

#lang racket

(provide (all-defined-out))
(require racket/mpair)
(require "utilities.rkt")

;; Environment representation.

(define global-env (mlist))
(define (set-global-env! e) (set! global-env e)) ; for primitive generation

(define-struct var
  (id ; identifier?
   global?
   (refs #:mutable)
   (sets #:mutable)
   (def  #:mutable) ; #f or node
   (needed? #:mutable)
   primitive)
  #:transparent)

(define-struct primitive
  (nargs
   (constant-folder #:mutable) ; added post-creation
   (eta-expansion   #:mutable) ; for higher-order uses
   unspecified-result?)
  #:transparent)

(define/contract (make-primitive-var id prim)
  (identifier? primitive? . -> . var?)
  (make-var id #t '() '() #f #f prim))
(define/contract (make-global-var    id def)
  (identifier? any/c      . -> . var?)
  (make-var id #t '() '() def #f #f))
(define/contract (make-local-var     id def)
  (identifier? any/c      . -> . var?)
  (make-var id #f '() '() def #f #f))

(define (var-bare-id v) (syntax->datum (var-id v))) ; for code-generation

;; Once we plug in Racket's expander, we'll be able to do better.
(define (var=? x y)
  (and (id=? (var-id  x) (var-id  y))   ; same symbol
       (eq?  (var-def x) (var-def y)))) ; defined in the same place
(define (id=?  x y) (eq?  (syntax->datum x) (syntax->datum y)))


(define allow-forward-references? (make-parameter #t))

(define/contract (env-lookup env id) ((mlistof var?) identifier? . -> . var?)
  (or (for/first ([b (in-mlist env)]
                  #:when (id=? (var-id b) id))
        b)
      ;; We didn't find it. If reasonable to do so, add it to the env.
      ;; This makes it possible to have forward references at the top level.
      (let ([x (make-var id #t '() '() #f #f #f)])
        (unless (allow-forward-references?)
          (compiler-error "variable referenced before its definition:" id))
        (mappend! env (mlist x))
        x)))

(define/contract (env-extend env ids def)
  ((mlistof var?) (listof identifier?) any/c . -> . (mlistof var?))
  (mappend (list->mlist
            (map (lambda (id)
                   (make-var id #f '() '() def #f #f))
                 ids))
           env))


;; extra code environment : list of AST nodes
;; To hold code generated by the compiler that must be compiled along with the
;; rest of the program (e.g. primitive eta-expansions).
;; All this code needs to be generated before compilation begins, and will be
;; merged with the rest of the program after parsing.
(define extra-code-env '())
(define (add-extra-code c) (set! extra-code-env (cons c extra-code-env)))
